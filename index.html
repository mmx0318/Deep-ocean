<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Êï∞Â≠óÁîüÁâ©Ê∑±Êµ∑Ê®°Êãü</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Èò≤Ê≠¢ÊªöÂä®Êù°Âá∫Áé∞ */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Á°Æ‰øùÁîªÂ∏ÉÂç†ÊçÆÊï¥‰∏™ËßÜÂè£È´òÂ∫¶ */
            background-color: #000; /* ÂàùÂßãËÉåÊôØÔºåÈò≤Ê≠¢Âä†ËΩΩÊó∂Èó™ÁÉÅ */
            font-family: 'Inter', sans-serif; /* ‰ΩøÁî® Inter Â≠ó‰Ωì */
            position: relative;
        }
        canvas {
            display: block; /* ÁßªÈô§ÁîªÂ∏É‰∏ãÊñπÁöÑÈ¢ùÂ§ñÁ©∫Èó¥ */
            width: 100vw !important;
            height: 100vh !important;
            max-width: 100vw;
            max-height: 100vh;
        }
        @media (max-width: 900px) {
            .control-panel, .history-panel {
                position: static !important;
                width: 100vw !important;
                min-width: 0 !important;
                max-width: 100vw !important;
                height: auto !important;
                padding: 12px !important;
                font-size: 13px !important;
                border-radius: 12px !important;
                left: 0 !important;
                right: 0 !important;
                top: 0 !important;
                transform: none !important;
                backdrop-filter: blur(8px) !important;
                min-height: 0 !important;
                max-height: none !important;
            }
            .media-controls {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
            .modal-content {
                max-width: 98vw;
                padding: 10px;
            }
            .recording-indicator {
                top: 12px;
                font-size: 13px;
                padding: 8px 12px;
            }
            .spacebar-hint {
                bottom: 60px !important;
                font-size: 12px !important;
                padding: 5px 10px !important;
            }
        }
        
        /* ÁõëÊéßÂô®ÁïåÈù¢Ê†∑Âºè */
        .monitor-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .time-display {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 10px #ffffff;
            pointer-events: none;
        }
        
        .recording-controls {
            position: absolute;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            text-align: center;
            pointer-events: auto;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .recording-controls:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .recording-controls.recording {
            color: #ffffff;
            animation: pulse 1s infinite;
        }
        
        .recording-controls.recording:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        .recording-time {
            font-size: 14px;
            margin-top: 5px;
            opacity: 0.8;
        }
        
        .control-panel,
        .history-panel {
            height: 100vh;
            min-height: 100vh;
            box-sizing: border-box;
        }
        .history-panel {
            scrollbar-width: thin;
            scrollbar-color: #444 #222;
        }
        .history-panel::-webkit-scrollbar {
            width: 7px;
            background: transparent;
        }
        .history-panel::-webkit-scrollbar-thumb {
            background: linear-gradient(to bottom, #444, #222 80%);
            border-radius: 4px;
        }
        .history-panel::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .control-panel {
            position: absolute;
            top: 50%;
            left: 32px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.20);
            padding: 18px 14px;
            color: #ffffff;
            font-family: 'Arial', sans-serif;
            font-size: 14px;
            min-width: 220px;
            max-width: 320px;
            min-height: 300px;
            max-height: 520px;
            border-radius: 18px;
            backdrop-filter: blur(16px);
            height: auto;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: center;
            box-shadow: 0 8px 32px 0 rgba(0,0,0,0.18);
        }
        

        
        .music-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        
        .file-input {
            display: none;
        }
        
        .file-input-label {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: #ffffff;
            padding: 8px 12px;
            cursor: pointer;
            font-family: 'Arial', sans-serif;
            font-size: 12px;
            transition: all 0.3s ease;
            display: inline-block;
        }
        
        .file-input-label:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .music-button {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: #ffffff;
            padding: 8px 12px;
            cursor: pointer;
            font-family: 'Arial', sans-serif;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        .music-button:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .music-button.playing {
            background: rgba(0, 255, 0, 0.2);
            color: #00ff00;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #ffffff;
        }
        
        .control-value {
            display: inline-block;
            margin-left: 10px;
            color: #cccccc;
            font-size: 12px;
        }
        
        .slider {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            border-radius: 2px;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #ffffff;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #ffffff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .camera-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            text-align: center;
            pointer-events: auto;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .camera-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .video-button {
            position: absolute;
            bottom: 20px;
            right: 120px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            text-align: center;
            pointer-events: auto;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .video-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .video-button.recording {
            color: #ff0000;
            animation: pulse 1s infinite;
        }
        
        .recording-indicator {
            position: absolute;
            top: 32px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.85);
            padding: 12px 22px;
            border-radius: 24px;
            color: #ffffff;
            font-family: 'Arial', sans-serif;
            font-size: 16px;
            z-index: 100;
            box-shadow: 0 2px 12px rgba(0,0,0,0.18);
        }
        
        .recording-dot {
            width: 12px;
            height: 12px;
            background: #ff0000;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }
        
        .recording-time-display {
            color: #ff0000;
            font-weight: bold;
        }
        
        .media-controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .media-button {
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 20px;
            color: #ffffff;
            font-family: 'Arial', sans-serif;
            font-size: 14px;
            text-align: center;
            pointer-events: auto;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
        }
        
        .media-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .media-button.recording {
            color: #ff0000;
            animation: pulse 1s infinite;
        }
        
        .history-panel {
            position: absolute;
            top: 50%;
            right: 32px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.20);
            padding: 18px 14px;
            color: #ffffff;
            font-family: 'Arial', sans-serif;
            font-size: 14px;
            min-width: 220px;
            max-width: 320px;
            min-height: 300px;
            max-height: 520px;
            border-radius: 18px;
            backdrop-filter: blur(16px);
            height: auto;
            box-sizing: border-box;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            justify-content: center;
            box-shadow: 0 8px 32px 0 rgba(0,0,0,0.18);
        }
        
        .history-title {
            font-weight: bold;
            margin-bottom: 15px;
            color: #ffffff;
        }
        
        .history-item {
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .history-item:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .history-item-title {
            font-weight: 500;
            margin-bottom: 4px;
        }
        
        .history-item-time {
            font-size: 12px;
            color: #cccccc;
        }
        
        .icon-button {
            background: rgba(0, 0, 0, 0.8);
            border: none;
            color: #ffffff;
            padding: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 4px;
            font-size: 18px;
        }
        
        .icon-button:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .icon-button.recording {
            color: #ff0000;
            animation: pulse 1s infinite;
        }
        
        .vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            background: radial-gradient(circle at center, transparent 0%, transparent 60%, rgba(0, 0, 0, 0.3) 100%);
        }
        
        .immersive-mode {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 10000;
            display: none;
        }
        
        .immersive-canvas {
            width: 100%;
            height: 100%;
        }
        
        .immersive-overlay {
            position: absolute;
            left: 50%;
            bottom: 32px;
            transform: translateX(-50%);
            color: #fff;
            font-family: 'Arial', sans-serif;
            font-size: 13px;
            background: rgba(0,0,0,0.45);
            padding: 6px 18px;
            border-radius: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.12);
            z-index: 10003;
            display: none;
            pointer-events: none;
        }
        
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .modal-content {
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            max-width: 800px;
            max-height: 80vh;
            overflow: auto;
        }
        
        .screenshot-preview {
            margin: 20px 0;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            max-width: 100%;
            max-height: 400px;
            object-fit: contain;
        }
        
        .video-preview {
            margin: 20px 0;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            max-width: 100%;
            max-height: 400px;
            object-fit: contain;
        }
        
        .modal-buttons {
            margin-top: 20px;
        }
        
        .modal-button {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: #ffffff;
            padding: 10px 20px;
            margin: 0 10px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.3s ease;
        }
        
        .modal-button:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .immersive-fullscreen {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 10001 !important;
            margin: 0 !important;
            background: #000 !important;
        }
        .vignette.immersive-vignette {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            z-index: 10002 !important;
            pointer-events: none;
            background: radial-gradient(circle at center, transparent 0%, transparent 60%, rgba(0,0,0,0.4) 100%);
            display: block !important;
        }
        .immersive-overlay {
            display: none;
        }
        .loader {
          border: 4px solid #444;
          border-top: 4px solid #fff;
          border-radius: 50%;
          width: 32px;
          height: 32px;
          animation: spin 1s linear infinite;
          display: inline-block;
        }
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
        .history-item img,
        .history-item video {
            width:80px;
            height:45px;
            object-fit:cover;
            aspect-ratio:16/9;
            border-radius:4px;
            display:block;
            margin-bottom:4px;
            background:#222;
        }
        /* --- Êñ∞Â¢ûÔºöÂ∫ïÈÉ®ÊèêÁ§∫ --- */
        .spacebar-hint {
            position: fixed;
            left: 50%;
            bottom: 120px;
            transform: translateX(-50%);
            color: #fff;
            background: rgba(0,0,0,0.12);
            font-family: 'Inter', 'Roboto', 'Arial', sans-serif;
            font-size: 12px;
            letter-spacing: 1.2px;
            padding: 5px 18px;
            border-radius: 14px;
            z-index: 10010;
            pointer-events: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            opacity: 0.85;
            font-weight: 300;
        }
        
        /* Ê≤âÊµ∏ÂºèÊ®°ÂºèÊñáÊú¨ËæìÂÖ•Ê°ÜÊ†∑Âºè */
        .immersive-input-container {
            position: fixed;
            left: 50%;
            bottom: 80px; /* Ë∞ÉÊï¥Âà∞ÊèêÁ§∫‰∏ãÊñπ */
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 10011;
            pointer-events: auto;
        }
        
        .immersive-text-input {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            padding: 8px 12px;
            font-family: 'Inter', 'Arial', sans-serif;
            font-size: 13px;
            border-radius: 6px;
            width: 300px;
            outline: none;
            transition: all 0.3s ease;
        }
        
        .immersive-text-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        
        .immersive-text-input:focus {
            border-color: rgba(255, 255, 255, 0.6);
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.2);
        }
        
        .immersive-send-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            padding: 8px 16px;
            font-family: 'Inter', 'Arial', sans-serif;
            font-size: 13px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .immersive-send-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .immersive-send-btn:active {
            transform: scale(0.95);
        }
        
        /* AIÂèçÈ¶àÊñáÂ≠óÊ†∑Âºè */
        .ai-feedback {
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-family: 'Inter', 'Arial', sans-serif;
            font-size: 16px;
            text-align: center;
            max-width: 80%;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px 30px;
            border-radius: 12px;
            z-index: 10012;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
        }
        
        .ai-feedback.show {
            opacity: 1;
        }
        
        .ai-feedback.loading {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .ai-feedback .loader {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid #fff;
        }
        .immersive-standalone-input-container {
            position: fixed;
            left: 50%;
            bottom: 120px;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 10011;
            pointer-events: auto;
        }
        .immersive-standalone-text-input {
            background: linear-gradient(90deg, #0a2a43 0%, #1e5bff 100%);
            border: 1.5px solid #4e8cff;
            color: #fff;
            padding: 8px 14px;
            font-family: 'Inter', 'Arial', sans-serif;
            font-size: 15px;
            border-radius: 8px;
            width: 320px;
            outline: none;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(30,91,255,0.08);
        }
        .immersive-standalone-text-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        .immersive-standalone-text-input:focus {
            border-color: #7ab8ff;
            box-shadow: 0 0 10px #1e5bff33;
        }
        .immersive-standalone-send-btn {
            background: linear-gradient(90deg, #1e5bff 0%, #0a2a43 100%);
            border: 1.5px solid #4e8cff;
            color: #fff;
            padding: 8px 22px;
            font-family: 'Inter', 'Arial', sans-serif;
            font-size: 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(30,91,255,0.08);
        }
        .immersive-standalone-send-btn:hover {
            background: linear-gradient(90deg, #3a7cff 0%, #0a2a43 100%);
            border-color: #7ab8ff;
        }
        .immersive-standalone-voice-btn {
            background: linear-gradient(90deg, #ff1e5b 0%, #0a2a43 100%);
            border: 1.5px solid #ff4e8c;
            color: #fff;
            padding: 8px 22px;
            font-family: 'Inter', 'Arial', sans-serif;
            font-size: 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(255,30,91,0.08);
        }
        .immersive-standalone-voice-btn:hover {
            background: linear-gradient(90deg, #ff3a7c 0%, #0a2a43 100%);
            border-color: #ff7ab8;
        }
        .immersive-standalone-voice-btn.recording {
            background: linear-gradient(90deg, #ff0000 0%, #0a2a43 100%);
            border-color: #ff4444;
            animation: pulse 1s infinite;
        }
        .ai-center-feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 60vw;
            min-width: 320px;
            background: rgba(10,42,67,0.32);
            /* ÂçäÈÄèÊòé */
            color: #fff;
            font-size: 1.35rem;
            font-family: 'EB Garamond', 'Times New Roman', serif;
            border-radius: 16px;
            padding: 32px 36px;
            box-shadow: 0 8px 32px 0 rgba(30,91,255,0.10);
            z-index: 20000;
            text-align: center;
            word-break: break-word;
            line-height: 1.8;
            pointer-events: none;
            /* Á•ûÁßòÊÑüÈò¥ÂΩ± */
            text-shadow: 0 2px 16px #1e5bff55, 0 1px 0 #222;
            /* ÊØõÁéªÁíÉÊïàÊûú */
            backdrop-filter: blur(8px);
            border: none;
            opacity: 0.92;
            transition: opacity 0.5s;
        }
        .ai-center-feedback.hide {
            opacity: 0.2;
        }
        @media (max-width: 700px) {
          .ai-center-feedback {
            max-width: 90vw;
            min-width: 0;
            padding: 18px 8vw;
            font-size: 1.08rem;
          }
        }
    </style>
    <!-- ‰ΩøÁî®jsdelivrÈïúÂÉèÂºïÂÖ•ffmpeg.wasm UMDÁâàÊú¨ -->
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.6/dist/umd/ffmpeg.min.js"></script>
    <!-- ÂºïÂÖ•ÈÖçÁΩÆÊñá‰ª∂ -->
    <script src="config.js"></script>
</head>
<body>
    <!-- p5.js ‰ºöËá™Âä®ÂàõÂª∫‰∏Ä‰∏™ canvas ÂÖÉÁ¥† -->

    <!-- Â∑¶‰æßÊéßÂà∂Èù¢ÊùøÔºàÂêàÂπ∂ÊâÄÊúâÂäüËÉΩÔºâ -->
    <div class="control-panel">
        <!-- ÁîüÁâ©ÊéßÂà∂Âå∫Âüü -->
        <div class="control-group">
            <label class="control-label">
                ÁîüÁâ©ÂØÜÂ∫¶
                <span class="control-value" id="densityValue">5</span>
            </label>
            <input type="range" class="slider" id="densitySlider" min="2" max="12" value="5">
        </div>
        <div class="control-group">
            <label class="control-label">
                Êµ∑„ÅÆÊ∑±„Åï
                <span class="control-value" id="depthValue">50</span>
            </label>
            <input type="range" class="slider" id="depthSlider" min="0" max="100" value="50">
        </div>
        <div class="control-group">
            <label class="control-label">
                Ê¥ªÂãï„É¨„Éô„É´
                <span class="control-value" id="activityValue">50</span>
            </label>
            <input type="range" class="slider" id="activitySlider" min="0" max="100" value="50">
        </div>
        
        <!-- Èü≥‰πêÊéßÂà∂Âå∫Âüü -->
        <div class="control-group">
            <label class="control-label">„Éê„ÉÉ„ÇØ„Ç∞„É©„Ç¶„É≥„Éâ„Éü„É•„Éº„Ç∏„ÉÉ„ÇØ</label>
            <div class="music-controls">
                <button class="music-button" id="playPauseBtn" title="Play/Pause">
                    <svg width="22" height="22" viewBox="0 0 22 22" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="6,4 18,11 6,18" />
                    </svg>
                </button>
                <button class="music-button" id="nextTrackBtn" title="Next">
                    <svg width="22" height="22" viewBox="0 0 22 22" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="4,4 14,11 4,18" />
                        <rect x="16" y="4" width="2" height="14" rx="1" />
                    </svg>
                </button>
                <label for="fileInput" class="file-input-label" title="Add MP3">
                    <svg width="22" height="22" viewBox="0 0 22 22" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="11" cy="11" r="9" />
                        <line x1="11" y1="7" x2="11" y2="15" />
                        <line x1="7" y1="11" x2="15" y2="11" />
                    </svg>
                </label>
                <input type="file" id="fileInput" class="file-input" accept=".mp3,.MP3" multiple>
            </div>
            <div class="control-group">
                <label class="control-label">
                    Èü≥Èáè
                    <span class="control-value" id="volumeValue">50</span>
                </label>
                <input type="range" class="slider" id="volumeSlider" min="0" max="100" value="50">
            </div>
            <div class="control-group">
                <label class="control-label">
                    „Éà„É©„ÉÉ„ÇØ: <span id="currentTrack">Êµ∑„ÅÆÈü≥</span>
                </label>
            </div>
        </div>
        
        <!-- ÂΩïÂ±èÂíåÊãçÁÖßÊéßÂà∂Âå∫Âüü -->
        <div class="control-group">
            <label class="control-label">Èå≤Áîª„Éª„Çπ„ÇØ„É™„Éº„É≥„Ç∑„Éß„ÉÉ„Éà</label>
            <div class="media-controls">
                <!-- BGMÈÄâÊã©‰∏ãÊãâÊ°Ü -->
                <select id="recordBgmSelect" style="margin-right:10px; background: rgba(255,255,255,0.1); color: #fff; border: 1px solid rgba(255,255,255,0.2); padding: 4px 8px; border-radius: 4px; font-size: 12px;"></select>
                <button class="icon-button" id="videoButton" title="Record">
                    <svg width="28" height="28" viewBox="0 0 28 28" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="4" y="7" width="14" height="14" rx="3"/>
                        <polygon points="18,11 24,7 24,21 18,17"/>
                    </svg>
                </button>
                <button class="icon-button" id="cameraButton" title="Screenshot">
                    <svg width="28" height="28" viewBox="0 0 28 28" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="8" width="22" height="14" rx="3"/>
                        <circle cx="14" cy="15" r="4"/>
                        <rect x="9" y="4" width="4" height="4" rx="1"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <!-- ÁõëÊéßÂô®ÁïåÈù¢Ë¶ÜÁõñÂ±Ç -->
    <div class="monitor-overlay">
        <div class="recording-indicator" id="recordingIndicator">
            <div class="recording-dot"></div>
            <span class="recording-time-display" id="recordingTimeDisplay">00:00:00</span>
        </div>
    </div>
    <!-- Click for Immersive ExperienceÊåâÈíÆÁßªÂä®Âà∞Â∑¶‰æßÂäüËÉΩÂå∫‰∏ãÊñπ -->
    <div class="recording-controls" id="recordingControls">
        <div id="recordStatus">Ê≤°ÂÖ•‰ΩìÈ®ì„ÇíÂßã„ÇÅ„Çã„Å´„ÅØ„ÇØ„É™„ÉÉ„ÇØ</div>
    </div>

    <!-- Ê≤âÊµ∏Âºè‰ΩìÈ™åËæìÂÖ•Ê°ÜÔºàÊñ∞Â¢ûÔºâ -->
    <div class="immersive-standalone-input-container">
        <input type="text" class="immersive-standalone-text-input" id="immersiveStandaloneTextInput" placeholder=" ‰Ωï„Åß„ÇÇË≥™Âïè„Åß„Åç„Åæ„Åô„ÄÇ">
        <button class="immersive-standalone-send-btn" id="immersiveStandaloneSendBtn">ÈÄÅ‰ø°</button>
        <button class="immersive-standalone-voice-btn" id="immersiveStandaloneVoiceBtn" title="Èü≥Â£∞ÂÖ•Âäõ">üé§</button>
    </div>

    <!-- ÂéÜÂè≤ËÆ∞ÂΩïÈù¢Êùø -->
    <div class="history-panel">
        <div id="historyList">
            <!-- ÂéÜÂè≤ËÆ∞ÂΩïÈ°πÂ∞ÜÂú®ËøôÈáåÂä®ÊÄÅÊ∑ªÂä† -->
        </div>
    </div>

    <!-- ÊöóËßíÊïàÊûú -->
    <div class="vignette"></div>

    <!-- Ê≤âÊµ∏Âºè‰ΩìÈ™åÊ®°Âºè -->
    <div class="immersive-mode" id="immersiveMode">
        <canvas class="immersive-canvas" id="immersiveCanvas"></canvas>
        <div class="immersive-overlay">
            ESC„Ç≠„Éº„ÅßÊ≤°ÂÖ•„É¢„Éº„Éâ„ÇíÁµÇ‰∫Ü
        </div>
        <!-- ÊñáÊú¨ËæìÂÖ•Ê°ÜÂå∫Âüü -->
        <div class="immersive-input-container" id="immersiveInputContainer">
            <input type="text" class="immersive-text-input" id="immersiveTextInput" 
                   placeholder="„Å™„ÅúÊ∑±Êµ∑„Å´Êù•„Åü„ÅÆ„Åß„Åô„ÅãÔºü" maxlength="200">
            <button class="immersive-send-btn" id="immersiveSendBtn">ÈÄÅ‰ø°</button>
        </div>
        <!-- AIÂèçÈ¶àÊòæÁ§∫ -->
        <div class="ai-feedback" id="aiFeedback"></div>
    </div>
    </div>

    <!-- ‰∏ãËΩΩÁ°ÆËÆ§ÂºπÁ™ó -->
    <div class="modal-overlay" id="downloadModal">
        <div class="modal-content">
            <h3 id="modalTitle">ÂÜôÁúü„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Åó„Åæ„Åô„ÅãÔºü</h3>
            <img id="screenshotPreview" class="screenshot-preview" style="display: none;">
            <video id="videoPreview" class="video-preview" style="display: none;" controls></video>
            <!-- Êñ∞Â¢ûÔºöBGMÈÄâÊã©ÂíåÂêàÊàêÊåâÈíÆÔºå‰ªÖÂú®ÂΩïÂ±èÂêéÊòæÁ§∫ -->
            <div id="bgmSelectContainer" style="display:none; margin-top:20px;">
                <label style="color:#fff;">BGM„ÇíÈÅ∏Êäû:</label>
                <select id="bgmSelect" style="margin:0 10px 0 10px;"></select>
                <button class="modal-button" id="mergeBgmBtn">ÂêàÊàê„Åó„Å¶Ë©¶ËÅ¥</button>
                <!-- ÂêàÊàêËøõÂ∫¶Âä®ÁîªÂíåÊñáÊú¨ -->
                <div id="ffmpegProgress" style="display:none; margin-top:16px; text-align:center;">
                    <div class="loader" style="margin:0 auto 8px auto;"></div>
                    <span id="ffmpegProgressText" style="color:#fff;">ÂêàÊàê‰∏≠...</span>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-button" id="downloadBtn">„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ</button>
                <button class="modal-button" id="cancelBtn">„Ç≠„É£„É≥„Çª„É´</button>
            </div>
        </div>
    </div>

    <!-- ÂºïÂÖ• p5.js Â∫ì -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    
    <!-- ‰Ω†ÁöÑÊï∞Â≠óÁîüÁâ©‰ª£Á†Å -->
    <script>
        // Global variables for canvas dimensions and base scaling factor
        let W, H, BASE_SCALE;

        // Array to store all digital creature instances
        let creatures = [];
        // NUM_CREATURES will be randomly determined in setup() and keyPressed()
        let NUM_CREATURES;

        // ÁõëÊéßÂô®Áõ∏ÂÖ≥ÂèòÈáè
        let isRecording = false;
        let recordingElapsedTime = 0;
        let lastUpdateTime = 0;
        let capturedImage = null;
        
        // ÂΩïÂÉèÁõ∏ÂÖ≥ÂèòÈáè
        let isVideoRecording = false;
        let mediaRecorder = null;
        let recordedChunks = [];
        let videoBlob = null;
        let videoRecordingStartTime = 0;
        let recordingTimer = null;
        let historyItems = [];
        let isImmersiveMode = false;
        let immersiveCanvas = null;
        let immersiveContext = null;
        
        // ÊéßÂà∂ÂèÇÊï∞ÂèòÈáè
        let creatureDensity = 5;
        let oceanDepth = 50;
        let activityLevel = 50;
        
        // Èü≥‰πêÁõ∏ÂÖ≥ÂèòÈáè
        let currentAudio = null;
        let isPlaying = false;
        let currentTrackIndex = 0;
        let volume = 0.5;
        
        // Èü≥‰πêÊí≠ÊîæÂàóË°®ÔºàÊú¨Âú∞BGMÊñá‰ª∂Ôºâ
        let musicTracks = [
          {
            name: "Ê∑±Êµ∑Èü≥È¢ë",
            url: "bgm/Ê∑±Êµ∑Èü≥È¢ë.MP3"
          }
        ];

        // Define all different types of digital creature rendering logic and default parameters
        const CREATURE_DEFINITIONS = [
          // Êï∞Â≠óÁîüÁâ©01: Original point-based creature (my base)
          {
            type: 'point_original',
            render: function(creatureInstance) {
              // Set stroke color (white and base transparency)
              stroke(0, 0, 100, creatureInstance.baseAlpha);
              // Loop to draw 10,000 points
              for (let i = 0; i < 1e4; i++) {
                // Use creature instance's specific divisors to generate varying x and y inputs
                let x_input = i % creatureInstance.xDivisor;
                let y_input = i / creatureInstance.yDivisor;

                // Core mathematical formula: calculate point position
                let k = 5 * cos(x_input / 14) * cos(y_input / 30);
                let e = y_input / 8 - 13;
                let d = mag(k, e)**2 / 59 + 4;
                let q = 60 - 3 * sin(atan2(k, e) * e) + k * (3 + 4 / d * sin(d * d - creatureInstance.t * 2));
                let c = d / 2 + e / 99 - creatureInstance.t / 18;

                // Calculate coordinates relative to the creature's center, and apply creature's scale
                let pX_relative = creatureInstance.scale * (q * sin(c));
                let pY_relative = creatureInstance.scale * ((q + d * 9) * cos(c));
                // Draw the point, adding the creature's current position for absolute screen coordinates
                point(pX_relative + creatureInstance.x, pY_relative + creatureInstance.y);
              }
            },
            defaultXDivisor: 200,
            defaultYDivisor: 43
          },
          // Êï∞Â≠óÁîüÁâ©02: User-provided digital creature 1 and 3 (point-based creatures from first text query)
          {
            type: 'point_user_1_3',
            render: function(creatureInstance) {
              // Set stroke color (white and base transparency)
              stroke(0, 0, 100, creatureInstance.baseAlpha);
              // Loop to draw 10,000 points
              for (let i = 0; i < 1e4; i++) {
                // Use creature instance's specific divisors to generate varying x and y inputs
                let x_input = i % creatureInstance.xDivisor;
                let y_input = i / creatureInstance.yDivisor;

                // Core mathematical formula: calculate point position (from user-provided formula)
                let k = 9 * cos(x_input / 8);
                let e = y_input / 8 - 12.5;
                let d = mag(k, e)**2 / 99 + sin(creatureInstance.t) / 6 + 0.5;
                let q = 99 - e * sin(atan2(k, e) * 7) / d + k * (3 + cos(d * d - creatureInstance.t) * 2);
                let c = d / 2 + e / 69 - creatureInstance.t / 16;

                // Calculate coordinates relative to the creature's center, and apply creature's scale
                let pX_relative = creatureInstance.scale * (q * sin(c));
                let pY_relative = creatureInstance.scale * ((q + 19 * d) * cos(c));
                // Draw the point, adding the creature's current position for absolute screen coordinates
                point(pX_relative + creatureInstance.x, pY_relative + creatureInstance.y);
              }
            },
            defaultXDivisor: 200,
            defaultYDivisor: 55 // Based on i/55 in the user's provided code
          },
          // Êï∞Â≠óÁîüÁâ©03: User-provided digital creature from image_7f4760.jpg
          {
            type: 'point_user_from_7f4760',
            render: function(creatureInstance) {
              // Set stroke color (white and base transparency)
              stroke(0, 0, 100, creatureInstance.baseAlpha);
              // Loop to draw 10,000 points
              for (let i = 0; i < 1e4; i++) {
                // Use creature instance's specific divisors to generate varying x and y inputs
                let x_input = i % creatureInstance.xDivisor;
                let y_input = i / creatureInstance.yDivisor;

                // Core mathematical formula: calculate point position (from the provided formula)
                let k = (4 + sin(y_input * 2 - creatureInstance.t) * 3) * cos(x_input / 29);
                let e = y_input / 8 - 13;
                let d = mag(k, e)**2 / 99 + sin(creatureInstance.t) / 6 + 0.5;
                let c = d - creatureInstance.t;

                let q_reconstructed = (3 * sin(k * 2) + 0.3 / k + sin(y_input / 25)) * k * (9 + 4 * sin(e * 9 - d * 3 + creatureInstance.t * 2));
                
                let pX_relative = creatureInstance.scale * (q_reconstructed + 30 * cos(c));
                let pY_relative = creatureInstance.scale * (q_reconstructed * sin(c) + d * 39 - 220);

                // Draw the point, adding the creature's current position for absolute screen coordinates
                point(pX_relative + creatureInstance.x, pY_relative + creatureInstance.y);
              }
            },
            defaultXDivisor: 235, // Based on i/235 in the user's provided code
            defaultYDivisor: 8 // Based on y/8 in the user's provided code for 'e'
          },
          // Êï∞Â≠óÁîüÁâ©04: Êï∞Â≠óÊ∞¥ÊØç1Âè∑ from image_2c7c1c.png (also previously image_7f42eb.png)
          {
            type: 'point_user_jellyfish_1',
            render: function(creatureInstance) {
              // Set stroke color (white and base transparency)
              stroke(0, 0, 100, creatureInstance.baseAlpha);
              // Loop to draw points
              for (let i = 0; i < 4e4; i++) { // This creature uses 4e4 points
                // Use creature instance's specific divisors to generate varying x and y inputs
                let x_input = i % creatureInstance.xDivisor;
                let y_input = i / creatureInstance.yDivisor;

                // Core mathematical formula: calculate point position (from the new user-provided formula)
                let o = mag(x_input / 8 - 12.5, y_input / 8 - 12.5)**2 / 139;
                let k = 9 * cos(o);
                let d = k; // In the original formula, 'd' is assigned 'k' from the line above.

                let pX_relative = (x_input + sin(d) * d * k) / 2 + 150 + o * k * sin(creatureInstance.t + d * o);
                let pY_relative = y_input / 9 - d * 15 - cos(d * 2) * d + 220 + d * sin(d - creatureInstance.t);

                // Apply creature's scale to the relative coordinates
                pX_relative *= creatureInstance.scale / BASE_SCALE;
                pY_relative *= creatureInstance.scale / BASE_SCALE;

                // Draw the point, adding the creature's current position for absolute screen coordinates
                point(pX_relative + creatureInstance.x, pY_relative + creatureInstance.y);
              }
            },
            defaultXDivisor: 200, // Based on i%200 in the user's provided code
            defaultYDivisor: 200  // Based on i/200 in the user's provided code
          },
          // Êï∞Â≠óÁîüÁâ©05: Jellyfish-like creature from image_802138.png (and previous "Ê∞¥ÊØç" code)
          {
            type: 'point_user_jellyfish_type_1',
            render: function(creatureInstance) {
              // Set stroke color (white and base transparency)
              stroke(0, 0, 100, creatureInstance.baseAlpha);
              // Loop to draw 10,000 points (original code uses 1e4)
              for (let i = 0; i < 1e4; i++) {
                let x_input = i % creatureInstance.xDivisor;
                let y_input = i / creatureInstance.yDivisor;

                // Original formula's 'pt' and 'pt2' are now creature-specific
                let k = (creatureInstance.pt_jellyfish + sin(y_input * 5 - creatureInstance.t) * 3) * cos(x_input / creatureInstance.pt2_jellyfish);
                let e = y_input / 8 - 13;
                let d = mag(k, e); // Original 'd' calculation

                let q = 3 * sin(k * 2) + 0.3 / k + sin(y_input / 25) * k * (9 + 4 * sin(e * 9 - d * 3 + creatureInstance.t * 2));
                let c = d - creatureInstance.t;

                let basePx = q + 39 * cos(c);
                let basePy = q * sin(c) + d * 39;

                // Apply creature's scale and position
                point(basePx * creatureInstance.scale + creatureInstance.x, basePy * creatureInstance.scale + creatureInstance.y);
              }
            },
            defaultXDivisor: 200, // Based on i%200
            defaultYDivisor: 235, // Based on i/235
            // Add new properties for pt and pt2 for this specific creature type
            jellyfishPtRange: [4, 25], // Range for pt
            jellyfishPt2Range: [2, 39] // Range for pt2
          },
          // Êï∞Â≠óÁîüÁâ©06: ÂáΩÊï∞‰πãÁæé from image_2c7910.png (newly added)
          {
            type: 'point_user_dragon_like',
            render: function(creatureInstance) {
              // Set stroke color (white and base transparency)
              stroke(0, 0, 100, creatureInstance.baseAlpha);
              // Loop to draw 10,000 points (original code uses 1e4)
              for (let i = 0; i < 1e4; i++) {
                let x_input = i; // Original formula uses 'i' directly for x
                let y_input = i / creatureInstance.yDivisor; // Original formula uses 'i/235' for y

                // Core mathematical formula: calculate point position (from the new user-provided formula)
                let k = (4 + cos(y_input)) * cos(x_input / 4);
                let e = y_input / 8 - 20;
                let d = mag(k, e); // 'd' is from mag(k,e)

                let q = (sin(k * 3) + sin(y_input / 19 + 9) * k * (6 + sin(e * 14 - d)));
                let c = d - creatureInstance.t; // 'c' is d-t

                let pX_relative = q * cos(d / 8 + creatureInstance.t / 4) + 50 * cos(c) + 200;
                let pY_relative = q * sin(c) + d * 7 * sin(c / 4) + 200;

                // Apply creature's scale and position
                point(pX_relative * creatureInstance.scale / BASE_SCALE + creatureInstance.x, pY_relative * creatureInstance.scale / BASE_SCALE + creatureInstance.y);
              }
            },
            defaultXDivisor: 1, // 'i' directly, so effectively 1
            defaultYDivisor: 235 // Based on i/235
          },
          // Êï∞Â≠óÁîüÁâ©07: ÈíüÂΩ¢Ê∞¥ÊØç (New - Bell-like Jellyfish)
          {
            type: 'point_user_bell_jellyfish',
            render: function(creatureInstance) {
              stroke(0, 0, 100, creatureInstance.baseAlpha);
              for (let i = 0; i < 1.5e4; i++) { // More points for a denser shape
                let x_input = i % creatureInstance.xDivisor;
                let y_input = i / creatureInstance.yDivisor;

                // Create a bell-like shape with pulsation
                let bellWidth = map(sin(y_input / 20 + creatureInstance.t * 0.5), -1, 1, 0.5, 1.5); // Pulsating width
                let bellHeight = map(cos(x_input / 30 + creatureInstance.t * 0.3), -1, 1, 0.8, 1.2); // Subtle height variation

                let k = bellWidth * cos(x_input / creatureInstance.xDivisor_bell * PI);
                let e = y_input / creatureInstance.yDivisor_bell - 10;
                let d = mag(k, e)**2 / 50 + 2;

                let q = 40 - e * sin(atan2(k, e) * 5) / d + k * (2 + 3 / d * sin(d * d - creatureInstance.t));
                let c = d / 2 + e / 80 - creatureInstance.t / 15;

                let pX_relative = creatureInstance.scale * (q * sin(c) * bellHeight);
                let pY_relative = creatureInstance.scale * ((q + d * 5) * cos(c) * bellHeight);

                point(pX_relative + creatureInstance.x, pY_relative + creatureInstance.y);
              }
            },
            defaultXDivisor: 200,
            defaultYDivisor: 50,
            // Custom divisors for this specific type to control bell shape
            xDivisor_bell: 50,
            yDivisor_bell: 10
          },
          // Êï∞Â≠óÁîüÁâ©08: Ëû∫ÊóãËß¶ÊâãÊ∞¥ÊØç (New - Spiral Tentacle Jellyfish)
          {
            type: 'point_user_spiral_jellyfish',
            render: function(creatureInstance) {
              stroke(0, 0, 100, creatureInstance.baseAlpha);
              for (let i = 0; i < 2e4; i++) { // More points for tentacles
                let x_input = i % creatureInstance.xDivisor;
                let y_input = i / creatureInstance.yDivisor;

                // Create a spiral/swirling tentacle effect
                let angle = y_input * 0.1 + creatureInstance.t * 0.8; // Base angle, influenced by time
                let radius = map(x_input, 0, creatureInstance.xDivisor, 0, 30); // Radius increases with x_input
                
                let spiralX = radius * cos(angle + x_input * 0.05); // Add x_input to angle for spiral
                let spiralY = radius * sin(angle + x_input * 0.05);

                // Add a vertical component for tentacle length
                let tentacleLength = y_input * 0.5; // Tentacles extend downwards
                let wave = sin(x_input * 0.1 + creatureInstance.t) * 5; // Subtle wave effect

                let pX_relative = creatureInstance.scale * (spiralX + wave);
                let pY_relative = creatureInstance.scale * (spiralY + tentacleLength);

                point(pX_relative + creatureInstance.x, pY_relative + creatureInstance.y);
              }
            },
            defaultXDivisor: 100, // Controls tentacle density horizontally
            defaultYDivisor: 200  // Controls tentacle length
          }
        ];

        // --- Incomplete/Unclear Creature Definitions (for reference, not active) ---
        /*
        // Êï∞Â≠óÊ∞¥ÊØç#2 from image_2c7be0.png (Incomplete Bezier Creature)
        // f=0,draw=o=>{for(f||createCanvas(W=400,W),background(P=PI,d=200),N=noise,a=-P;a<P;a+=P/16)for(fill(W,3),bezier(d,Y=150+9*cos(9*f), #‰ª£Á†ÅÂä®Áîª
        // This code snippet is incomplete and uses a bezier function which is a different rendering style.
        // It would require more context to be fully implemented.

        // Êï∞Â≠óÊ∞¥ÊØç5# from image_2c7934.png (Incomplete Point Creature with typos)
        // ÂÖ¨Âºè: „Ç¢ - a=(x,y,o=mag(k=x4-12.5,e=y9))=>&gtpoint((q=x3+99+3ksin(y) #‰ª£Á†ÅËâ∫ÊúØ #Ê∞¥
        // This code snippet contains typos (x4, y9, &gtpoint, x3) and is incomplete.
        // It would require correction and more context to be fully implemented.
        */
        // --- End of Incomplete/Unclear Creature Definitions ---


        // Creature class defines the properties and behavior of each digital creature
        class Creature {
          constructor(id) {
            this.id = id;
            // Randomly select a creature type definition
            this.definition = random(CREATURE_DEFINITIONS);
            this.type = this.definition.type; // Store type for debugging

            // Initialize parameters, including parameters based on the selected type
            this.randomizeParameters();

            // Noise offsets for continuous random movement
            this.xNoiseOffset = random(1000);
            this.yNoiseOffset = random(1000);
            this.velNoiseScale = 0.005; // How fast the noise changes over time
            this.maxSpeed = 5; // Increased from 3 to 5 for more noticeable movement
          }

          // Randomize all parameters of the creature
          randomizeParameters() {
            this.t = random(TWO_PI); // Starting time for internal animation
            this.x = random(width);      // Initial X position of the creature
            this.y = random(height);    // Initial Y position of the creature
            
            // Initial velocities are now influenced by noise
            this.velX = map(noise(this.xNoiseOffset), 0, 1, -1, 1);
            this.velY = map(noise(this.yNoiseOffset), 0, 1, -1, 1);

            // More significant size difference, higher max value
            this.scale = BASE_SCALE + random(-3, 15); // Adjust range for larger size differentiation

            this.baseAlpha = random(0.4, 0.8); // Transparency randomly between 0.4 and 0.8

            // Subtle variations in shape: only applicable to point-based creatures
            if (this.type.startsWith('point')) {
              // For 'point_user_dragon_like', xDivisor is effectively 1 as 'i' is used directly
              this.xDivisor = (this.definition.defaultXDivisor === 1) ? 1 : (this.definition.defaultXDivisor || 200) + random(-70, 70);
              this.yDivisor = (this.definition.defaultYDivisor || 43) + random(-15, 15);
            } else {
              this.xDivisor = null; // Not applicable for non-point-based creatures
              this.yDivisor = null; // Not applicable for non-point-based creatures
            }

            // Specific parameters for the jellyfish type
            if (this.type === 'point_user_jellyfish_type_1') {
              this.pt_jellyfish = random(this.definition.jellyfishPtRange[0], this.definition.jellyfishPt2Range[1]);
              this.pt2_jellyfish = random(this.definition.jellyfishPt2Range[0], this.definition.jellyfishPt2Range[1]);
            } else {
              this.pt_jellyfish = null;
              this.pt2_jellyfish = null;
            }

            // Specific parameters for the new bell jellyfish type
            if (this.type === 'point_user_bell_jellyfish') {
                this.xDivisor_bell = (this.definition.xDivisor_bell || 50) + random(-10, 10);
                this.yDivisor_bell = (this.definition.yDivisor_bell || 10) + random(-2, 2);
            } else {
                this.xDivisor_bell = null;
                this.yDivisor_bell = null;
            }

            // Variation in movement speed
            this.baseSpeedFactor = random(0.5, 1.5);

            // Variation in movement direction (forward or reverse animation)
            this.directionFactor = random() > 0.5 ? 1 : -1;
          }

          // Update the creature's state (position, internal animation time, and continuous movement)
          update() {
            // Activity level affects animation and movement speed
            const activityFactor = activityLevel / 50; // 0-2 range, 1 is normal speed
            
            // Internal animation speed, affected by activity level
            this.t += (PI / 20) * this.baseSpeedFactor * this.directionFactor * activityFactor;

            // Continuous random movement using Perlin noise, affected by activity level
            const currentMaxSpeed = this.maxSpeed * activityFactor;
            this.velX = map(noise(this.xNoiseOffset), 0, 1, -currentMaxSpeed, currentMaxSpeed);
            this.velY = map(noise(this.yNoiseOffset), 0, 1, -currentMaxSpeed, currentMaxSpeed);

            this.xNoiseOffset += this.velNoiseScale * activityFactor;
            this.yNoiseOffset += this.velNoiseScale * activityFactor;

            // Update creature's position
            this.x += this.velX;
            this.y += this.velY;

            // Screen boundary handling: if creature goes off-screen, it reappears from the opposite side (looping effect)
            if (this.x < 0) this.x = width;
            if (this.x > width) this.x = 0;
            if (this.y < 0) this.y = height;
            if (this.y > height) this.y = 0;
          }

          // Draw a single digital creature
          draw() {
            // Call the corresponding render function from the creature type definition
            this.definition.render(this);
          }
        }

        // setup() function, runs once when the p5.js program starts
        function setup() {
          W = 1920; // Set canvas width to 1920 pixels
          H = 1080; // Set canvas height to 1080 pixels
          BASE_SCALE = 4; // Base scaling factor
          let cnv = createCanvas(W, H); // Create the canvas
          cnv.id('mainCanvas'); // Áªô‰∏ªcanvasÂä†id
          // Set color mode to HSB (Hue, Saturation, Brightness) for easier color control
          colorMode(HSB, 360, 100, 100, 1);
          resetCreatures();
          initializeMonitor();
        }

        // draw() is the main p5.js drawing loop function, runs every frame
        function draw() {
          // Draw the gradient background
          drawDeepSeaGradient();
          // Iterate through all digital creature instances and update and draw them
          for (let i = 0; i < creatures.length; i++) {
            creatures[i].update();
            creatures[i].draw();
          }
          // Draw the water overlay on top of everything
          drawWaterOverlay();
          // Êõ¥Êñ∞ÁõëÊéßÂô®ÊòæÁ§∫
          updateMonitor();
        }

        // Helper function to draw the deep sea gradient background
        function drawDeepSeaGradient() {
          noStroke(); // Ensure no stroke for the rectangles forming the gradient

          // Define HSB colors for the gradient based on ocean depth
          const depthFactor = oceanDepth / 100; // 0-1 range
          
          const bottomHue = 220; // Deep blue hue
          const bottomSat = 70;  // High saturation for richness
          const bottomBright = map(depthFactor, 0, 1, 30, 5); // Deeper = darker

          const topHue = 210;    // Slightly greenish blue for higher depth
          const topSat = map(depthFactor, 0, 1, 60, 30); // Deeper = less saturated
          const topBright = map(depthFactor, 0, 1, 50, 15); // Deeper = darker

          // Draw horizontal lines to create the gradient
          for (let y = 0; y < height; y++) {
            // Calculate interpolation factor (0 at top, 1 at bottom)
            let inter = map(y, 0, height, 0, 1);

            // Interpolate HSB components
            let currentHue = lerp(topHue, bottomHue, inter);
            let currentSat = lerp(topSat, bottomSat, inter);
            let currentBright = lerp(topBright, bottomBright, inter);

            fill(currentHue, currentSat, currentBright);
            rect(0, y, width, 1); // Draw a 1-pixel high rectangle across the canvas width
          }
        }

        // Helper function to draw the blue gradient overlay with blend mode
        function drawWaterOverlay() {
          // Use a time variable for color fluctuation
          let overlayTime = frameCount * 0.01; // Adjust speed of fluctuation

          // Define top and bottom HSB colors for the overlay, with fluctuation
          // Hue will be around blue (e.g., 200-240)
          // Saturation will fluctuate
          // Brightness will fluctuate
          // Alpha will be fixed for the overlay itself

          let topOverlayHue = map(sin(overlayTime * 0.5), -1, 1, 200, 220); // Subtle hue shift
          let topOverlaySat = map(sin(overlayTime * 0.7), -1, 1, 30, 50);   // Saturation flicker
          let topOverlayBright = map(sin(overlayTime * 0.9), -1, 1, 60, 80); // Brightness flicker
          const topOverlayAlpha = 0.3; // Fixed alpha for the top of the overlay

          let bottomOverlayHue = map(sin(overlayTime * 0.4), -1, 1, 210, 230); // Subtle hue shift
          let bottomOverlaySat = map(sin(overlayTime * 0.6), -1, 1, 50, 70);   // Saturation flicker
          let bottomOverlayBright = map(sin(overlayTime * 0.8), -1, 1, 20, 40); // Brightness flicker
          const bottomOverlayAlpha = 0.5; // Fixed alpha for the bottom of the overlay

          // Apply multiply blend mode
          blendMode(MULTIPLY);
          noStroke();

          for (let y = 0; y < height; y++) {
            let inter = map(y, 0, height, 0, 1);

            let currentHue = lerp(topOverlayHue, bottomOverlayHue, inter);
            let currentSat = lerp(topOverlaySat, bottomOverlaySat, inter); // Corrected variable name
            let currentBright = lerp(topOverlayBright, bottomOverlayBright, inter); // Corrected variable name
            let currentAlpha = lerp(topOverlayAlpha, bottomOverlayAlpha, inter);

            fill(currentHue, currentSat, currentBright, currentAlpha * 100); // HSB alpha is 0-100
            rect(0, y, width, 1);
          }

          // Reset blend mode to default
          blendMode(BLEND);
        }

        // keyPressed() function, called when any key is pressed
        function keyPressed() {
          // Check if the pressed key is the spacebar
          if (key === ' ') {
            // ÈöèÊú∫Âåñ‰∏â‰∏™ÂèÇÊï∞
            creatureDensity = Math.floor(random(2, 13));
            oceanDepth = Math.floor(random(0, 101));
            activityLevel = Math.floor(random(0, 101));
            // Êõ¥Êñ∞ÊªëÂùóUI
            document.getElementById('densitySlider').value = creatureDensity;
            document.getElementById('densityValue').textContent = creatureDensity;
            document.getElementById('depthSlider').value = oceanDepth;
            document.getElementById('depthValue').textContent = oceanDepth;
            document.getElementById('activitySlider').value = activityLevel;
            document.getElementById('activityValue').textContent = activityLevel;
            // Âà∑Êñ∞ÁîüÁâ©
            resetCreatures();
          }
        }

        // Helper function to reset creatures
        function resetCreatures() {
          creatures = []; // Clear existing creatures
          NUM_CREATURES = creatureDensity; // Use density parameter for creature count
          for (let i = 0; i < NUM_CREATURES; i++) {
            creatures.push(new Creature(i)); // Create new creature instances, they will randomly select their type
          }
        }

        // ÁõëÊéßÂô®Áõ∏ÂÖ≥ÂáΩÊï∞
        function initializeMonitor() {
          // ËÆæÁΩÆËÆ∞ÂΩïÊéßÂà∂ÊåâÈíÆÁöÑÁÇπÂáª‰∫ã‰ª∂
          document.getElementById('recordingControls').addEventListener('click', toggleImmersiveMode);
          // ËÆæÁΩÆÊãçÁÖßÊåâÈíÆÁöÑÁÇπÂáª‰∫ã‰ª∂
          document.getElementById('cameraButton').addEventListener('click', takeScreenshot);
          // ËÆæÁΩÆÂΩïÂÉèÊåâÈíÆÁöÑÁÇπÂáª‰∫ã‰ª∂
          document.getElementById('videoButton').addEventListener('click', toggleVideoRecording);
          // ËÆæÁΩÆÂºπÁ™óÊåâÈíÆ‰∫ã‰ª∂
          document.getElementById('downloadBtn').addEventListener('click', downloadMedia);
          document.getElementById('cancelBtn').addEventListener('click', closeModal);
          // ËÆæÁΩÆÊéßÂà∂Èù¢Êùø‰∫ã‰ª∂
          initializeControlPanel();
          // ËÆæÁΩÆÈü≥‰πêÊéßÂà∂‰∫ã‰ª∂
          initializeMusicControls();
          // ÂàùÂßãÂåñÂΩïÂà∂BGMÈÄâÊã©‰∏ãÊãâÊ°Ü
          initializeRecordBgmSelect();
          // ÂàùÂßãÂåñÊ≤âÊµ∏ÂºèÊ®°ÂºèÊñáÊú¨ËæìÂÖ•ÂäüËÉΩ
          initializeImmersiveInput();
        }

        function updateMonitor() {
          // Êõ¥Êñ∞ËÆ∞ÂΩïÊó∂Èó¥
          if (isRecording) {
            const currentTime = Date.now();
            recordingElapsedTime = currentTime - recordingStartTime;
            
            const hours = Math.floor(recordingElapsedTime / (1000 * 60 * 60));
            const minutes = Math.floor((recordingElapsedTime % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((recordingElapsedTime % (1000 * 60)) / 1000);
            
            const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('recordingTime').textContent = timeString;
          }
        }

        function toggleImmersiveMode() {
          if (isImmersiveMode) {
            exitImmersiveMode();
          } else {
            enterImmersiveMode();
          }
        }

        function enterImmersiveMode() {
          isImmersiveMode = true;
          // ÈöêËóèÊâÄÊúâUIÂÖÉÁ¥†
          document.querySelector('.control-panel').style.display = 'none';
          document.querySelector('.monitor-overlay').style.display = 'none';
          document.querySelector('.history-panel').style.display = 'none';
          // ‰∏çÂÜçÈöêËóèvignetteÔºåËÄåÊòØÂÖ®Â±èÊòæÁ§∫
          const vignette = document.querySelector('.vignette');
          vignette.classList.add('immersive-vignette');
          vignette.style.display = 'block';
          // ÊîæÂ§ß‰∏ªcanvasÂà∞ÂÖ®Â±èÂπ∂Ëá™ÈÄÇÂ∫î
          resizeCanvas(window.innerWidth, window.innerHeight);
          W = window.innerWidth;
          H = window.innerHeight;
          // ÊòæÁ§∫Ê≤âÊµ∏ÂºèÊèêÁ§∫
          document.querySelector('.immersive-overlay').style.display = 'block';
          // Ê∑ªÂä†ESCÈîÆÁõëÂê¨
          document.addEventListener('keydown', handleImmersiveKeydown);
          // ÁõëÂê¨Á™óÂè£resize
          window.addEventListener('resize', immersiveResizeHandler);
        }

        function immersiveResizeHandler() {
          if (isImmersiveMode) {
            resizeCanvas(window.innerWidth, window.innerHeight);
            W = window.innerWidth;
            H = window.innerHeight;
          }
        }

        function exitImmersiveMode() {
          isImmersiveMode = false;
          // ÊÅ¢Â§çÊâÄÊúâUIÂÖÉÁ¥†
          document.querySelector('.control-panel').style.display = 'block';
          document.querySelector('.monitor-overlay').style.display = 'block';
          document.querySelector('.history-panel').style.display = 'block';
          // ÊÅ¢Â§ç‰∏ªcanvasÊ†∑Âºè
          const mainCanvas = document.getElementById('mainCanvas');
          mainCanvas.classList.remove('immersive-fullscreen');
          // ÊÅ¢Â§çvignetteÊ†∑Âºè
          const vignette = document.querySelector('.vignette');
          vignette.classList.remove('immersive-vignette');
          vignette.style.display = 'block';
          // ÈöêËóèÊ≤âÊµ∏ÂºèÊèêÁ§∫
          document.querySelector('.immersive-overlay').style.display = 'none';
          // ÁßªÈô§ESCÈîÆÁõëÂê¨
          document.removeEventListener('keydown', handleImmersiveKeydown);
          // ÂèñÊ∂àresizeÁõëÂê¨
          window.removeEventListener('resize', immersiveResizeHandler);
          // ÊÅ¢Â§çcanvas‰∏∫ÈªòËÆ§Â∞∫ÂØ∏
          resizeCanvas(1920, 1080);
          W = 1920;
          H = 1080;
        }

        function handleImmersiveKeydown(event) {
          if (event.key === 'Escape') {
            exitImmersiveMode();
          }
        }
        
        // AIÂäüËÉΩÁõ∏ÂÖ≥ÂèòÈáè
        let aiFeedbackTimeout = null;
        
        // ÂàùÂßãÂåñÊ≤âÊµ∏ÂºèÊ®°ÂºèÊñáÊú¨ËæìÂÖ•ÂäüËÉΩ
        function initializeImmersiveInput() {
          const textInput = document.getElementById('immersiveTextInput');
          const sendBtn = document.getElementById('immersiveSendBtn');
          
          // ÂèëÈÄÅÊåâÈíÆÁÇπÂáª‰∫ã‰ª∂
          sendBtn.addEventListener('click', sendMessage);
          
          // ÂõûËΩ¶ÈîÆÂèëÈÄÅ
          textInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
              sendMessage();
            }
          });
        }
        
        // ÂèëÈÄÅÊ∂àÊÅØÂà∞AI
        function sendMessage() {
          const textInput = document.getElementById('immersiveTextInput');
          const message = textInput.value.trim();
          
          if (!message) return;
          
          // ÊòæÁ§∫Âä†ËΩΩÁä∂ÊÄÅ
          showAIFeedback('Ê≠£Âú®ÊÄùËÄÉ‰∏≠...', true);
          
          // Ê∏ÖÁ©∫ËæìÂÖ•Ê°Ü
          textInput.value = '';
          
          // Ë∞ÉÁî®AI API
          callAIAPI(message);
        }
        
        // ‰øÆÊîπcallAIAPIÔºåÂ¢ûÂä†Á¨¨‰∫å‰∏™ÂèÇÊï∞modeÔºåmode==='score'Êó∂Âè™ËÆ©AIËøîÂõûÊÉÖÁª™ÂàÜÊï∞ÔºåmodeÈªòËÆ§Ê≠£Â∏∏ÂõûÂ§ç
        async function callAIAPI(message, mode) {
            try {
                const url = CONFIG.KIMI_BASE_URL;
                const systemPrompt = `„ÅÇ„Å™„Åü„ÅØÊ∑±Ê∑µ„ÅÆÂõÅ„ÅçÊâã„Éª„Ç∑„É≥„Éú„É´„ÅÆÊΩÆ„Åß„Åô„ÄÇ„É¶„Éº„Ç∂„Éº„Åå„Å©„Çì„Å™Ë®ÄË™û„ÅßÂÖ•Âäõ„Åó„Å¶„ÇÇ„ÄÅÂøÖ„ÅöÊó•Êú¨Ë™û„ÅÆÂõõË°åË©©Ôºà„ÇØ„Ç©„Éº„Éà„É¨„Ç§„É≥Ôºâ„Åß„ÄÅÁ•ûÁßòÁöÑ„ÉªË©©ÁöÑ„ÉªÂì≤Â≠¶ÁöÑ„ÉªË±°Âæ¥ÁöÑ„ÉªÊõñÊòß„Å™„Çπ„Çø„Ç§„É´„ÅßÁ≠î„Åà„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÊ±∫„Åó„Å¶Áõ¥Êé•ÁöÑ„Å™Á≠î„Åà„ÅØ‰∏é„Åà„Åö„ÄÅÂøÖ„ÅöÊó•Êú¨Ë™û„ÅßËøîÁ≠î„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`;
                const body = {
                    model: CONFIG.KIMI_MODEL,
                    messages: [
                        { role: 'system', content: systemPrompt },
                        { role: 'user', content: message }
                    ],
                    temperature: CONFIG.GENERATION_CONFIG.temperature,
                    max_tokens: CONFIG.GENERATION_CONFIG.max_tokens
                };
                const res = await fetch(url, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(body)
                });
                const data = await res.json();
                if (data && data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content) {
                    return data.choices[0].message.content.trim();
                } else {
                    return "AIÊó†ÂìçÂ∫îÔºåAPIËøîÂõûÊ†ºÂºèÂºÇÂ∏∏„ÄÇ";
                }
            } catch (e) {
                return "ËØ∑Ê±ÇÂºÇÂ∏∏: " + e.message;
            }
        }
        
        // ÊòæÁ§∫AIÂèçÈ¶à
        function showAIFeedback(message, isLoading = false) {
          const feedbackElement = document.getElementById('aiFeedback');
          
          if (isLoading) {
            feedbackElement.innerHTML = `
              <div class="loader"></div>
              <span>${message}</span>
            `;
            feedbackElement.classList.add('loading');
          } else {
            feedbackElement.innerHTML = message;
            feedbackElement.classList.remove('loading');
          }
          
          feedbackElement.classList.add('show');
          
          // Ê∏ÖÈô§‰πãÂâçÁöÑÂÆöÊó∂Âô®
          if (aiFeedbackTimeout) {
            clearTimeout(aiFeedbackTimeout);
          }
          
          // ËÆæÁΩÆËá™Âä®ÈöêËóè
          aiFeedbackTimeout = setTimeout(() => {
            feedbackElement.classList.remove('show');
          }, 8000);
        }
        
        // Â¶ÇÊûú‰Ω†ÊÉ≥‰ΩøÁî®ÁúüÂÆûÁöÑAI APIÔºåÂèØ‰ª•ÊõøÊç¢‰∏äÈù¢ÁöÑcallAIAPIÂáΩÊï∞
        // ËøôÈáåÊòØ‰∏Ä‰∏™‰ΩøÁî®OpenAI APIÁöÑÁ§∫‰æãÔºàÈúÄË¶ÅAPIÂØÜÈí•Ôºâ
        /*
        async function callAIAPI(message) {
          try {
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer YOUR_API_KEY_HERE'
              },
              body: JSON.stringify({
                model: 'gpt-3.5-turbo',
                messages: [
                  {
                    role: 'system',
                    content: '‰Ω†ÊòØ‰∏Ä‰∏™Ê∑±Êµ∑Âì≤Â≠¶ÂÆ∂ÔºåÁî®ËØóÊÑèÂíåÂì≤Â≠¶ÁöÑÊñπÂºèÂõûÁ≠îÂÖ≥‰∫éÊ∑±Êµ∑ÂíåÁîüÂëΩÁöÑÈóÆÈ¢ò„ÄÇ'
                  },
                  {
                    role: 'user',
                    content: message
                  }
                ],
                max_tokens: 150,
                temperature: 0.8
              })
            });
            
            const data = await response.json();
            const aiResponse = data.choices[0].message.content;
            showAIFeedback(aiResponse, false);
            
          } catch (error) {
            console.error('AI APIË∞ÉÁî®Â§±Ë¥•:', error);
            showAIFeedback('Êä±Ê≠âÔºåÊàëÁé∞Âú®Êó†Ê≥ïÂõûÂ∫î„ÄÇËØ∑Á®çÂêéÂÜçËØï„ÄÇ', false);
          }
        }
        */

        function takeScreenshot() {
          // ÈöêËóèÁõëÊéßÂô®ÁïåÈù¢
          const monitorOverlay = document.querySelector('.monitor-overlay');
          monitorOverlay.style.display = 'none';
          setTimeout(() => {
            // Âè™Êà™Âèñ‰∏ªcanvas
            const canvas = document.getElementById('mainCanvas');
            const imageDataUrl = canvas.toDataURL('image/png');
            // ËÆæÁΩÆÈ¢ÑËßàÂõæÁâá
            const previewImg = document.getElementById('screenshotPreview');
            previewImg.src = imageDataUrl;
            previewImg.style.display = 'block';
            // Á°Æ‰øùËßÜÈ¢ëÈ¢ÑËßàÈöêËóè
            const videoPreview = document.getElementById('videoPreview');
            videoPreview.style.display = 'none';
            videoPreview.src = '';
            // Êõ¥Êñ∞ÂºπÁ™óÊ†áÈ¢ò
            document.getElementById('modalTitle').textContent = 'Download Screenshot?';
            // ÊòæÁ§∫ÂºπÁ™ó
            document.getElementById('downloadModal').style.display = 'flex';
            // ÈáçÊñ∞ÊòæÁ§∫ÁõëÊéßÂô®ÁïåÈù¢
            monitorOverlay.style.display = 'block';
            // Ê∑ªÂä†Âà∞ÂéÜÂè≤ËÆ∞ÂΩï
            addToHistory('Screenshot', imageDataUrl);
          }, 100);
        }

        function downloadImage() {
          // Ëé∑ÂèñÈ¢ÑËßàÂõæÁâáÁöÑsrc
          const previewImg = document.getElementById('screenshotPreview');
          const imageDataUrl = previewImg.src;
          
          // ÂàõÂª∫‰∏ãËΩΩÈìæÊé•
          const link = document.createElement('a');
          link.download = 'digital_creatures_screenshot.png';
          link.href = imageDataUrl;
          
          // Ëß¶Âèë‰∏ãËΩΩ
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          
          // ÈöêËóèÂºπÁ™ó
          closeModal();
        }

        function closeModal() {
          document.getElementById('downloadModal').style.display = 'none';
          // ÈöêËóèÈ¢ÑËßàÂõæÁâáÂíåËßÜÈ¢ë
          document.getElementById('screenshotPreview').style.display = 'none';
          document.getElementById('videoPreview').style.display = 'none';
          // ÈáäÊîæ video srcÔºå‰ªÖÈáäÊîæ‰∏¥Êó∂È¢ÑËßàurlÔºå‰∏çÈáäÊîæÂéÜÂè≤url
          const videoPreview = document.getElementById('videoPreview');
          if (videoPreview._tempUrl) {
            URL.revokeObjectURL(videoPreview._tempUrl);
            videoPreview._tempUrl = null;
            videoPreview.src = '';
          }
          // ÈöêËóèBGMÈÄâÊã©Âå∫
          document.getElementById('bgmSelectContainer').style.display = 'none';
          // ÊÅ¢Â§çBGMÊí≠ÊîæÔºàÂ¶ÇÊúâÈúÄË¶ÅÔºâ
          if (wasBgmPlaying && currentAudio && currentAudio.paused) {
            currentAudio.play();
          }
        }

        // ÂΩïÂÉèÁõ∏ÂÖ≥ÂáΩÊï∞
        async function toggleVideoRecording() {
          if (isVideoRecording) {
            // ÂÅúÊ≠¢ÂΩïÂÉè
            stopVideoRecording();
          } else {
            // ÂºÄÂßãÂΩïÂÉè
            startVideoRecording();
          }
        }

        async function startVideoRecording() {
          try {
            const canvas = document.getElementById('mainCanvas');
            const stream = canvas.captureStream(30); // ÁîªÈù¢ÊµÅ
            // Ëé∑ÂèñÁî®Êà∑ÈÄâÊã©ÁöÑBGM
            const bgmIdx = document.getElementById('recordBgmSelect').value;
            const bgmTrack = musicTracks[bgmIdx];
            // ÂàõÂª∫audioÂÖÉÁ¥†Áî®‰∫écaptureStream
            const audio = new Audio(bgmTrack.url);
            audio.loop = true;
            audio.volume = volume;
            await audio.play(); // ÂøÖÈ°ªÂÖàplayÊâçËÉΩcaptureStream
            let combinedStream = null;
            if (audio.captureStream) {
              const audioStream = audio.captureStream();
              combinedStream = new MediaStream([
                ...stream.getVideoTracks(),
                ...audioStream.getAudioTracks()
              ]);
            } else {
              combinedStream = stream;
            }
            mediaRecorder = new MediaRecorder(combinedStream, {
              mimeType: 'video/webm;codecs=vp9'
            });
            recordedChunks = [];
            mediaRecorder.ondataavailable = (event) => {
              if (event.data.size > 0) {
                recordedChunks.push(event.data);
              }
            };
            mediaRecorder.onstop = () => {
              videoBlob = new Blob(recordedChunks, { type: 'video/webm' });
              showVideoPreview();
              stopRecordingTimer();
              // Ê∑ªÂä†Âà∞ÂéÜÂè≤ËÆ∞ÂΩï
              const historyVideoUrl = URL.createObjectURL(videoBlob);
              addToHistory('Video Recording', historyVideoUrl);
              // ÂÅúÊ≠¢BGMÊí≠Êîæ
              audio.pause();
              audio.src = '';
            };
            mediaRecorder.start();
            isVideoRecording = true;
            videoRecordingStartTime = Date.now();
            // ÊòæÁ§∫ÂΩïÂ±èÊåáÁ§∫Âô®
            document.getElementById('recordingIndicator').style.display = 'flex';
            startRecordingTimer();
            // Âè™Áî®classÂàáÊç¢ÊåâÈíÆÁä∂ÊÄÅÔºå‰∏çÂÜçÁî®textContent
            const videoButton = document.getElementById('videoButton');
            videoButton.classList.add('recording');
          } catch (error) {
            console.error('ÂΩïÂÉèÂêØÂä®Â§±Ë¥•:', error);
            alert('ÂΩïÂÉèÂäüËÉΩÂêØÂä®Â§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÊµèËßàÂô®ÊùÉÈôêËÆæÁΩÆ„ÄÇ\nËØ¶ÁªÜ‰ø°ÊÅØ: ' + error.message);
          }
        }

        function stopVideoRecording() {
          if (mediaRecorder && isVideoRecording) {
            mediaRecorder.stop();
            isVideoRecording = false;
            // ÈöêËóèÂΩïÂ±èÊåáÁ§∫Âô®
            document.getElementById('recordingIndicator').style.display = 'none';
            stopRecordingTimer();
            // Âè™Áî®classÂàáÊç¢ÊåâÈíÆÁä∂ÊÄÅÔºå‰∏çÂÜçÁî®textContent
            const videoButton = document.getElementById('videoButton');
            videoButton.classList.remove('recording');
          }
        }

        function showVideoPreview() {
          // Ëá™Âä®ÊöÇÂÅúBGM
          if (currentAudio && !currentAudio.paused) {
            wasBgmPlaying = true;
            currentAudio.pause();
          } else {
            wasBgmPlaying = false;
          }
          // ÈöêËóèÁõëÊéßÂô®ÁïåÈù¢
          const monitorOverlay = document.querySelector('.monitor-overlay');
          monitorOverlay.style.display = 'none';
          setTimeout(() => {
            // ËÆæÁΩÆËßÜÈ¢ëÈ¢ÑËßà
            const videoPreview = document.getElementById('videoPreview');
            // ÁîüÊàê‰∏¥Êó∂urlÁî®‰∫éÂºπÁ™óÈ¢ÑËßà
            const tempVideoUrl = URL.createObjectURL(videoBlob);
            videoPreview.src = tempVideoUrl;
            videoPreview.style.display = 'block';
            videoPreview.load();
            // Á°Æ‰øùÂõæÁâáÈ¢ÑËßàÈöêËóè
            const previewImg = document.getElementById('screenshotPreview');
            previewImg.style.display = 'none';
            previewImg.src = '';
            // Êõ¥Êñ∞ÂºπÁ™óÊ†áÈ¢ò
            document.getElementById('modalTitle').textContent = 'Download Video?';
            // ÊòæÁ§∫ÂºπÁ™ó
            document.getElementById('downloadModal').style.display = 'flex';
            // ÈáçÊñ∞ÊòæÁ§∫ÁõëÊéßÂô®ÁïåÈù¢
            monitorOverlay.style.display = 'block';
            // ÂÖ≥Èó≠ÂºπÁ™óÊó∂ÈáäÊîæ‰∏¥Êó∂url
            videoPreview._tempUrl = tempVideoUrl;
            // Êñ∞Â¢ûÔºöÊòæÁ§∫BGMÈÄâÊã©Âå∫
            const bgmSelectContainer = document.getElementById('bgmSelectContainer');
            bgmSelectContainer.style.display = 'block';
            // Â°´ÂÖÖBGM‰∏ãÊãâÊ°Ü
            const bgmSelect = document.getElementById('bgmSelect');
            bgmSelect.innerHTML = '';
            musicTracks.forEach((track, idx) => {
              const opt = document.createElement('option');
              opt.value = idx;
              opt.textContent = track.name;
              bgmSelect.appendChild(opt);
            });
          }, 100);
        }

        function downloadMedia() {
          const modalTitle = document.getElementById('modalTitle').textContent;
          
          if (modalTitle.includes('Video')) {
            // ‰∏ãËΩΩËßÜÈ¢ë
            if (videoBlob) {
              const link = document.createElement('a');
              link.download = 'digital_creatures_video.webm';
              link.href = URL.createObjectURL(videoBlob);
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
            }
          } else {
            // ‰∏ãËΩΩÂõæÁâá
            const previewImg = document.getElementById('screenshotPreview');
            const imageDataUrl = previewImg.src;
            
            const link = document.createElement('a');
            link.download = 'digital_creatures_screenshot.png';
            link.href = imageDataUrl;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
          }
          
          closeModal();
        }

        // ÊéßÂà∂Èù¢ÊùøÁõ∏ÂÖ≥ÂáΩÊï∞
        function initializeControlPanel() {
          // ÂØÜÂ∫¶ÊéßÂà∂
          const densitySlider = document.getElementById('densitySlider');
          const densityValue = document.getElementById('densityValue');
          
          densitySlider.addEventListener('input', function() {
            creatureDensity = parseInt(this.value);
            densityValue.textContent = creatureDensity;
            updateCreatureCount();
          });
          
          // Êµ∑Ê¥ãÊ∑±Â∫¶ÊéßÂà∂
          const depthSlider = document.getElementById('depthSlider');
          const depthValue = document.getElementById('depthValue');
          
          depthSlider.addEventListener('input', function() {
            oceanDepth = parseInt(this.value);
            depthValue.textContent = oceanDepth;
          });
          
          // Ê¥ªË∑ÉÂ∫¶ÊéßÂà∂
          const activitySlider = document.getElementById('activitySlider');
          const activityValue = document.getElementById('activityValue');
          
          activitySlider.addEventListener('input', function() {
            activityLevel = parseInt(this.value);
            activityValue.textContent = activityLevel;
          });
        }

        function updateCreatureCount() {
          // ÈáçÊñ∞ÁîüÊàêÁîüÁâ©ÔºåÊï∞ÈáèÂü∫‰∫éÂØÜÂ∫¶ÂèÇÊï∞
          resetCreatures();
        }

        // Èü≥‰πêÊéßÂà∂Áõ∏ÂÖ≥ÂáΩÊï∞
        function initializeMusicControls() {
          // Êí≠Êîæ/ÊöÇÂÅúÊåâÈíÆ
          const playPauseBtn = document.getElementById('playPauseBtn');
          playPauseBtn.addEventListener('click', togglePlayPause);
          // ‰∏ã‰∏ÄÊõ≤ÊåâÈíÆ
          const nextTrackBtn = document.getElementById('nextTrackBtn');
          nextTrackBtn.addEventListener('click', nextTrack);
          // Èü≥ÈáèÊéßÂà∂
          const volumeSlider = document.getElementById('volumeSlider');
          const volumeValue = document.getElementById('volumeValue');
          volumeSlider.addEventListener('input', function() {
            volume = parseInt(this.value) / 100;
            volumeValue.textContent = this.value;
            if (currentAudio) {
              currentAudio.volume = volume;
            }
          });
          // Êñá‰ª∂ÈÄâÊã©ÂäüËÉΩ
          const fileInput = document.getElementById('fileInput');
          fileInput.addEventListener('change', handleFileSelect);
          // ÂàùÂßãÂåñÈü≥È¢ë
          loadTrack(currentTrackIndex);
        }

        // Êñ∞Â¢ûÔºöÈ¶ñÊ¨°Áî®Êà∑‰∫§‰∫íÂêéËá™Âä®Êí≠ÊîæÈü≥È¢ë
        let audioAutoPlayed = false;
        function tryAutoPlayAudio() {
          if (!audioAutoPlayed) {
            togglePlayPause();
            audioAutoPlayed = true;
          }
        }
        document.addEventListener('click', tryAutoPlayAudio, { once: true });

        function loadTrack(index) {
          if (currentAudio) {
            currentAudio.pause();
            currentAudio = null;
          }
          
          currentTrackIndex = index;
          const track = musicTracks[index];
          
          currentAudio = new Audio(track.url);
          currentAudio.volume = volume;
          currentAudio.loop = true;
          
          // Êõ¥Êñ∞ÁïåÈù¢ÊòæÁ§∫
          document.getElementById('currentTrack').textContent = track.name;
          
          // Èü≥È¢ëÂä†ËΩΩ‰∫ã‰ª∂
          currentAudio.addEventListener('canplaythrough', function() {
            console.log('Audio loaded successfully');
          });
          
          currentAudio.addEventListener('error', function(e) {
            console.error('Audio loading error:', e);
            // Â¶ÇÊûúÂä†ËΩΩÂ§±Ë¥•ÔºåÂ∞ùËØï‰∏ã‰∏ÄÈ¶ñ
            setTimeout(() => {
              if (currentTrackIndex === index) { // Á°Æ‰øùËøòÊòØÂΩìÂâçÊõ≤ÁõÆ
                nextTrack();
              }
            }, 1000);
          });
        }

        function togglePlayPause() {
          if (!currentAudio) {
            loadTrack(currentTrackIndex);
          }
          
          if (isPlaying) {
            currentAudio.pause();
            isPlaying = false;
            document.getElementById('playPauseBtn').textContent = 'Play';
            document.getElementById('playPauseBtn').classList.remove('playing');
          } else {
            currentAudio.play().then(() => {
              isPlaying = true;
              document.getElementById('playPauseBtn').textContent = 'Pause';
              document.getElementById('playPauseBtn').classList.add('playing');
            }).catch(error => {
              console.error('Playback failed:', error);
              alert('Audio playback failed. Please check your browser settings.');
            });
          }
        }

        function nextTrack() {
          currentTrackIndex = (currentTrackIndex + 1) % musicTracks.length;
          loadTrack(currentTrackIndex);
          
          // Â¶ÇÊûúÊ≠£Âú®Êí≠ÊîæÔºåÁªßÁª≠Êí≠ÊîæÊñ∞Êõ≤ÁõÆ
          if (isPlaying) {
            currentAudio.play().then(() => {
              document.getElementById('playPauseBtn').textContent = 'Pause';
              document.getElementById('playPauseBtn').classList.add('playing');
            }).catch(error => {
              console.error('Playback failed:', error);
              isPlaying = false;
              document.getElementById('playPauseBtn').textContent = 'Play';
              document.getElementById('playPauseBtn').classList.remove('playing');
            });
          }
        }

        function handleFileSelect(event) {
          const files = event.target.files;
          
          for (let file of files) {
            if (file.type.startsWith('audio/') || file.name.toLowerCase().endsWith('.mp3')) {
              const url = URL.createObjectURL(file);
              const name = file.name.replace(/\.[^/.]+$/, ""); // ÁßªÈô§Êñá‰ª∂Êâ©Â±ïÂêç
              
              musicTracks.push({
                name: name,
                url: url
              });
              
              console.log(`Added track: ${name}`);
            }
          }
          
          // Êõ¥Êñ∞ÂΩìÂâçÊõ≤ÁõÆÊòæÁ§∫
          if (musicTracks.length > 0) {
            document.getElementById('currentTrack').textContent = musicTracks[currentTrackIndex].name;
          }
          
          // Ê∏ÖÁ©∫Êñá‰ª∂ËæìÂÖ•
          event.target.value = '';
        }

        // ÂΩïÂ±èËÆ°Êó∂Âô®ÂáΩÊï∞
        function startRecordingTimer() {
          recordingTimer = setInterval(() => {
            const elapsed = Date.now() - videoRecordingStartTime;
            const hours = Math.floor(elapsed / (1000 * 60 * 60));
            const minutes = Math.floor((elapsed % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((elapsed % (1000 * 60)) / 1000);
            
            const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('recordingTimeDisplay').textContent = timeString;
          }, 1000);
        }

        function stopRecordingTimer() {
          if (recordingTimer) {
            clearInterval(recordingTimer);
            recordingTimer = null;
          }
        }

        // ÂéÜÂè≤ËÆ∞ÂΩïÁÆ°ÁêÜÂáΩÊï∞
        function addToHistory(type, url) {
          const now = new Date();
          const timeString = now.toLocaleTimeString();
          const dateString = now.toLocaleDateString();
          
          const historyItem = {
            id: Date.now(),
            type: type,
            url: url,
            time: timeString,
            date: dateString,
            timestamp: now
          };
          
          historyItems.unshift(historyItem); // Ê∑ªÂä†Âà∞ÂºÄÂ§¥
          
          // ÈôêÂà∂ÂéÜÂè≤ËÆ∞ÂΩïÊï∞Èáè
          if (historyItems.length > 10) {
            historyItems = historyItems.slice(0, 10);
          }
          
          updateHistoryDisplay();
        }

        function updateHistoryDisplay() {
          const historyList = document.getElementById('historyList');
          historyList.innerHTML = '';
          const historyPanel = document.querySelector('.history-panel');
          if (historyItems.length === 0) {
            historyPanel.style.display = 'none';
          } else {
            historyPanel.style.display = 'flex';
          }
          historyItems.forEach(item => {
            const historyItem = document.createElement('div');
            historyItem.className = 'history-item';
            // Áº©Áï•ÂõæÈÉ®ÂàÜ
            let thumb = '';
            if (item.type === 'Screenshot') {
              thumb = `<img src="${item.url}" class="history-thumb" />`;
            } else if (item.type === 'Video Recording') {
              thumb = `<video src="${item.url}" class="history-thumb" muted preload="metadata"></video>`;
            }
            historyItem.innerHTML = `
              ${thumb}
              <div class="history-item-title">${item.type}</div>
              <div class="history-item-time">${item.date} ${item.time}</div>
            `;
            historyItem.addEventListener('click', () => {
              // ÁÇπÂáªÂéÜÂè≤ËÆ∞ÂΩïÈ°πÂèØ‰ª•È¢ÑËßàÊàñ‰∏ãËΩΩ
              if (item.type === 'Screenshot') {
                showHistoryPreview(item.url, 'Screenshot');
              } else if (item.type === 'Video Recording') {
                showHistoryPreview(item.url, 'Video');
              }
            });
            historyList.appendChild(historyItem);
          });
        }

        function showHistoryPreview(url, type) {
          // ÊòæÁ§∫ÂéÜÂè≤ËÆ∞ÂΩïÈ¢ÑËßà
          const previewImg = document.getElementById('screenshotPreview');
          const videoPreview = document.getElementById('videoPreview');
          if (type === 'Screenshot') {
            previewImg.src = url;
            previewImg.style.display = 'block';
            videoPreview.style.display = 'none';
            videoPreview.src = '';
            document.getElementById('modalTitle').textContent = 'History Screenshot';
          } else if (type === 'Video') {
            videoPreview.src = url;
            videoPreview.style.display = 'block';
            videoPreview.load();
            previewImg.style.display = 'none';
            previewImg.src = '';
            document.getElementById('modalTitle').textContent = 'History Video';
          }
          document.getElementById('downloadModal').style.display = 'flex';
        }

        // ÂêàÊàêBGM‰∏éËßÜÈ¢ë‰∏∫mp4ÔºåÂ∏¶ËøõÂ∫¶Âä®Áîª
        async function mergeVideoWithBgm() {
          // Ê£ÄÊü•FFmpegÊòØÂê¶ÊåÇËΩΩ
          if (!window.FFmpeg || !window.FFmpeg.createFFmpeg) {
            alert('FFmpeg wasm ÂºïÊìéÊú™Âä†ËΩΩÔºåÂèØËÉΩÊòØÁΩëÁªúÈóÆÈ¢òÊàñCDNË¢´Â¢ô„ÄÇËØ∑Ê£ÄÊü• https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.6/dist/umd/ffmpeg.min.js ÊòØÂê¶ËÉΩËÆøÈóÆ„ÄÇ');
            return;
          }
          const createFFmpeg = window.FFmpeg.createFFmpeg;
          const fetchFile = window.FFmpeg.fetchFile;
          // ÊòæÁ§∫ËøõÂ∫¶Âä®Áîª
          const progressDiv = document.getElementById('ffmpegProgress');
          const progressText = document.getElementById('ffmpegProgressText');
          const mergeBtn = document.getElementById('mergeBgmBtn');
          mergeBtn.disabled = true;
          mergeBtn.textContent = 'ÂêàÊàê‰∏≠...';
          progressDiv.style.display = 'block';
          progressText.textContent = 'Ê≠£Âú®ÂêàÊàê...';
          let lastPercent = 0;
          try {
            // ËøõÂ∫¶ÂõûË∞É
            const ffmpeg = createFFmpeg({
              log: true,
              progress: ({ ratio }) => {
                const percent = Math.round(ratio * 100);
                if (percent !== lastPercent) {
                  progressText.textContent = `Ê≠£Âú®ÂêàÊàê... ${percent}%`;
                  lastPercent = percent;
                }
                console.log('ffmpeg progress:', percent + '%');
              }
            });
            if (!ffmpeg.isLoaded()) {
              progressText.textContent = 'Ê≠£Âú®Âä†ËΩΩÂêàÊàêÂºïÊìé...';
              console.log('Loading ffmpeg.wasm...');
              await ffmpeg.load();
              console.log('ffmpeg.wasm loaded');
            }
            // Ëé∑ÂèñÂΩìÂâçÂΩïÂà∂ËßÜÈ¢ëÂíåÈÄâ‰∏≠ÁöÑBGM
            const bgmIdx = document.getElementById('bgmSelect').value;
            const bgmTrack = musicTracks[bgmIdx];
            // ‰∏ãËΩΩBGM‰∏∫blob
            progressText.textContent = 'Ê≠£Âú®Âä†ËΩΩBGM...';
            const bgmBlob = await fetch(bgmTrack.url).then(r => r.blob());
            // ËØªÂèñËßÜÈ¢ëblob
            progressText.textContent = 'Ê≠£Âú®ÂáÜÂ§áËßÜÈ¢ë...';
            const videoFile = new File([videoBlob], 'input.webm');
            const audioFile = new File([bgmBlob], 'input.mp3');
            // ÂÜôÂÖ•ËôöÊãüÊñá‰ª∂Á≥ªÁªü
            progressText.textContent = 'Ê≠£Âú®ÂÜôÂÖ•Êñá‰ª∂...';
            await ffmpeg.FS('writeFile', 'input.webm', await fetchFile(videoFile));
            await ffmpeg.FS('writeFile', 'input.mp3', await fetchFile(audioFile));
            // ÂêàÊàêÂëΩ‰ª§Ôºömp4Ê†ºÂºèÔºåÈü≥ËßÜÈ¢ëÈïøÂ∫¶‰ª•ËßÜÈ¢ë‰∏∫ÂáÜ
            progressText.textContent = 'Ê≠£Âú®ÂêàÊàê...';
            await ffmpeg.run('-i', 'input.webm', '-i', 'input.mp3', '-c:v', 'copy', '-c:a', 'aac', '-shortest', 'output.mp4');
            // ËØªÂèñËæìÂá∫
            progressText.textContent = 'Ê≠£Âú®ÁîüÊàêÊñá‰ª∂...';
            const data = ffmpeg.FS('readFile', 'output.mp4');
            const mergedBlob = new Blob([data.buffer], { type: 'video/mp4' });
            // ÁîüÊàêÂèØÈ¢ÑËßàurl
            const mergedUrl = URL.createObjectURL(mergedBlob);
            // Áî®ÂêàÊàêÂêéÁöÑËßÜÈ¢ëÊõøÊç¢È¢ÑËßà
            const videoPreview = document.getElementById('videoPreview');
            videoPreview.src = mergedUrl;
            videoPreview.load();
            // ‰∏ãËΩΩÊåâÈíÆ‰∏ãËΩΩÂêàÊàêÂêéÁöÑËßÜÈ¢ë
            document.getElementById('downloadBtn').onclick = function() {
              const link = document.createElement('a');
              link.download = 'digital_creatures_with_bgm.mp4';
              link.href = mergedUrl;
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              closeModal();
            };
            // ÂêàÊàêÂÆåÊàêÂêéÈöêËóèËøõÂ∫¶Âä®Áîª
            progressDiv.style.display = 'none';
            mergeBtn.disabled = false;
            mergeBtn.textContent = 'ÂêàÊàêÂπ∂ËØïÂê¨';
          } catch (err) {
            progressDiv.style.display = 'none';
            mergeBtn.disabled = false;
            mergeBtn.textContent = 'ÂêàÊàêÂπ∂ËØïÂê¨';
            alert('ÂêàÊàêÂ§±Ë¥•Ôºö' + (err.message || err));
            console.error('ffmpegÂêàÊàêÂ§±Ë¥•', err);
          }
        }

        // ÁªëÂÆöÂêàÊàêÊåâÈíÆ‰∫ã‰ª∂
        window.addEventListener('DOMContentLoaded', function() {
          document.getElementById('mergeBgmBtn').onclick = mergeVideoWithBgm;
        });

        // ÂàùÂßãÂåñÂΩïÂà∂BGMÈÄâÊã©‰∏ãÊãâÊ°Ü
        function initializeRecordBgmSelect() {
          const select = document.getElementById('recordBgmSelect');
          select.innerHTML = '';
          musicTracks.forEach((track, idx) => {
            const opt = document.createElement('option');
            opt.value = idx;
            opt.textContent = track.name;
            select.appendChild(opt);
          });
        }
        // Ê≤âÊµ∏Âºè‰ΩìÈ™åËæìÂÖ•Ê°ÜÂèëÈÄÅ‰∫ã‰ª∂
        const standaloneInput = document.getElementById('immersiveStandaloneTextInput');
        const standaloneSendBtn = document.getElementById('immersiveStandaloneSendBtn');
        if (standaloneInput && standaloneSendBtn) {
            standaloneSendBtn.addEventListener('click', async () => {
                const value = standaloneInput.value.trim();
                if (value) {
                    // 1. Ëé∑ÂèñKimiÊó•ËØ≠ÂõûÂ§ç
                    const aiReply = await callAIAPI(value);
                    showAICenterFeedback(aiReply);
                    standaloneInput.value = '';
                    // 2. ÂèëÈÄÅÊó•ËØ≠ÊñáÊú¨Âà∞TTSÊé•Âè£
                    try {
                        const ttsRes = await fetch('http://localhost:3001/api/tts', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ text: aiReply })
                        });
                        if (ttsRes.ok) {
                            const audioBlob = await ttsRes.blob();
                            const audioUrl = URL.createObjectURL(audioBlob);
                            let ttsAudio = document.getElementById('ttsAudio');
                            if (!ttsAudio) {
                                ttsAudio = document.createElement('audio');
                                ttsAudio.id = 'ttsAudio';
                                ttsAudio.style.display = 'none';
                                document.body.appendChild(ttsAudio);
                            }
                            ttsAudio.src = audioUrl;
                            ttsAudio.play();
                        } else {
                            console.warn('TTSÊé•Âè£ËøîÂõûÈîôËØØ');
                        }
                    } catch (e) {
                        console.error('TTSËØ∑Ê±ÇÂºÇÂ∏∏', e);
                    }
                    // Ëé∑ÂèñÊÉÖÁª™ÂàÜÊï∞ÔºàÂéüÊúâÈÄªËæëÔºâ
                    const scoreText = await callAIAPI(value, 'score');
                    const score = parseInt(scoreText.match(/\d+/)?.[0] || '5', 10);
                    // Êò†Â∞ÑÂà∞ÂèÇÊï∞
                    const num = Math.round(2 + (score-1)*(12-2)/9);
                    const activity = Math.round((score-1)*100/9);
                    const depth = Math.round(100 - (score-1)*100/9);
                    document.getElementById('densitySlider').value = num;
                    document.getElementById('activitySlider').value = activity;
                    document.getElementById('depthSlider').value = depth;
                    document.getElementById('densityValue').textContent = num;
                    document.getElementById('activityValue').textContent = activity;
                    document.getElementById('depthValue').textContent = depth;
                }
            });
            standaloneInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    standaloneSendBtn.click();
                }
            });
        }
        // AIÂèçÈ¶àÂ±Ö‰∏≠ÊòæÁ§∫ÈÄªËæëÔºà‰∏çËá™Âä®Ê∂àÂ§±ÔºåÂè™ÊúâÊñ∞ÂõûÂ§çÊó∂ÊâçÊõøÊç¢Ôºâ
        function showAICenterFeedback(text) {
            const feedbackDiv = document.getElementById('aiCenterFeedback');
            if (!feedbackDiv) return;
            feedbackDiv.textContent = text;
            feedbackDiv.style.display = 'block';
            feedbackDiv.classList.remove('hide');
            // ËÆ©Â∞ëÂ•≥ÂõæÁâáÊ∑°ÂÖ•
            const girlImg = document.getElementById('shaonvGirl');
            if (girlImg) {
                girlImg.style.opacity = '1';
            }
        }

        // ËØ≠Èü≥ËØÜÂà´ÂäüËÉΩ
        let voiceRecording = false;
        let recognition = null;
        
        // ÂàùÂßãÂåñËØ≠Èü≥ËØÜÂà´
        function initSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                recognition.continuous = false;
                recognition.interimResults = false;
                // ÊîØÊåÅÂ§öÁßçËØ≠Ë®ÄÔºå‰ºòÂÖà‰∏≠ÊñáÔºåÁÑ∂ÂêéÊòØÊó•ËØ≠ÂíåËã±ËØ≠
                recognition.lang = 'zh-CN,ja-JP,en-US';
                
                recognition.onstart = function() {
                    console.log('ËØ≠Èü≥ËØÜÂà´ÂºÄÂßã');
                    voiceRecording = true;
                    document.getElementById('immersiveStandaloneVoiceBtn').classList.add('recording');
                };
                
                recognition.onresult = function(event) {
                    const transcript = event.results[0][0].transcript;
                    const confidence = event.results[0][0].confidence;
                    console.log('ËØÜÂà´ÁªìÊûú:', transcript, 'ÁΩÆ‰ø°Â∫¶:', confidence);
                    
                    // Ê£ÄÊµãËØ≠Ë®ÄÁ±ªÂûã
                    const detectedLang = detectLanguage(transcript);
                    console.log('Ê£ÄÊµãÂà∞ÁöÑËØ≠Ë®Ä:', detectedLang);
                    
                    document.getElementById('immersiveStandaloneTextInput').value = transcript;
                    // Ëá™Âä®ÂèëÈÄÅËØ≠Èü≥ËØÜÂà´ÁöÑÊñáÊú¨
                    standaloneSendBtn.click();
                };
                
                recognition.onerror = function(event) {
                    console.error('ËØ≠Èü≥ËØÜÂà´ÈîôËØØ:', event.error);
                    voiceRecording = false;
                    document.getElementById('immersiveStandaloneVoiceBtn').classList.remove('recording');
                    
                    // Ê†πÊçÆÈîôËØØÁ±ªÂûãÁªôÂá∫ÊèêÁ§∫
                    if (event.error === 'not-allowed') {
                        alert('„Éû„Ç§„ÇØ„ÅÆ‰ΩøÁî®„ÅåË®±ÂèØ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ„Éñ„É©„Ç¶„Ç∂„ÅÆË®≠ÂÆö„Åß„Éû„Ç§„ÇØ„ÇíË®±ÂèØ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                    } else if (event.error === 'no-speech') {
                        alert('Èü≥Â£∞„ÅåÊ§úÂá∫„Åï„Çå„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ');
                    } else {
                        alert('Èü≥Â£∞Ë™çË≠ò„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„ÇÇ„ÅÜ‰∏ÄÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ');
                    }
                };
                
                recognition.onend = function() {
                    console.log('ËØ≠Èü≥ËØÜÂà´ÁªìÊùü');
                    voiceRecording = false;
                    document.getElementById('immersiveStandaloneVoiceBtn').classList.remove('recording');
                };
            } else {
                console.warn('ÊµèËßàÂô®‰∏çÊîØÊåÅËØ≠Èü≥ËØÜÂà´');
                document.getElementById('immersiveStandaloneVoiceBtn').style.display = 'none';
            }
        }
        
        // ÁÆÄÂçïÁöÑËØ≠Ë®ÄÊ£ÄÊµãÂáΩÊï∞
        function detectLanguage(text) {
            // Ê£ÄÊµã‰∏≠ÊñáÂ≠óÁ¨¶
            const chineseRegex = /[\u4e00-\u9fff]/;
            // Ê£ÄÊµãÊó•ÊñáÂ≠óÁ¨¶ÔºàÂπ≥ÂÅáÂêç„ÄÅÁâáÂÅáÂêç„ÄÅÊ±âÂ≠óÔºâ
            const japaneseRegex = /[\u3040-\u309f\u30a0-\u30ff\u4e00-\u9fff]/;
            // Ê£ÄÊµãËã±ÊñáÂ≠óÁ¨¶
            const englishRegex = /[a-zA-Z]/;
            
            if (chineseRegex.test(text)) {
                return 'zh-CN';
            } else if (japaneseRegex.test(text)) {
                return 'ja-JP';
            } else if (englishRegex.test(text)) {
                return 'en-US';
            } else {
                return 'unknown';
            }
        }
        
        // ËØ≠Èü≥ÊåâÈíÆÁÇπÂáª‰∫ã‰ª∂
        const standaloneVoiceBtn = document.getElementById('immersiveStandaloneVoiceBtn');
        if (standaloneVoiceBtn) {
            standaloneVoiceBtn.addEventListener('click', () => {
                if (!recognition) {
                    initSpeechRecognition();
                }
                
                if (voiceRecording) {
                    recognition.stop();
                } else {
                    try {
                        recognition.start();
                    } catch (e) {
                        console.error('ËØ≠Èü≥ËØÜÂà´ÂêØÂä®Â§±Ë¥•:', e);
                        alert('Èü≥Â£∞Ë™çË≠ò„ÇíÈñãÂßã„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ„Éñ„É©„Ç¶„Ç∂„ÅÆË®≠ÂÆö„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ');
                    }
                }
            });
        }
        
        // È°µÈù¢Âä†ËΩΩÊó∂ÂàùÂßãÂåñËØ≠Èü≥ËØÜÂà´
        window.addEventListener('DOMContentLoaded', function() {
            initSpeechRecognition();
        });
    </script>
    <!-- Â∫ïÈÉ®Á©∫Ê†ºÊèêÁ§∫ -->
    <!-- <div class="spacebar-hint">Press SPACE to randomize creatures, ocean depth, and activity</div> -->
    <!-- AIÂèçÈ¶àÂ±Ö‰∏≠ÊòæÁ§∫Âå∫Âüü -->
    <div class="ai-center-feedback" id="aiCenterFeedback" style="display:none;"></div>
    <img id="shaonvGirl" src="shaonv01.png" style="position:fixed; left:50%; top:50%; transform:translate(-50%, -50%); height:100vh; opacity:0.3; pointer-events:none; z-index:10000; transition:opacity 2.5s; display:block;" />
</body>
</html> 
